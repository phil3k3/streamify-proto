import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "../../../common";
export interface NoNFTSuperTokenMockInterface extends utils.Interface {
    functions: {
        "castrate()": FunctionFragment;
        "createAgreement(bytes32,bytes32[])": FunctionFragment;
        "getAccountActiveAgreements(address)": FunctionFragment;
        "getAgreementData(address,bytes32,uint256)": FunctionFragment;
        "getAgreementStateSlot(address,address,uint256,uint256)": FunctionFragment;
        "getCodeAddress()": FunctionFragment;
        "getHost()": FunctionFragment;
        "initialize(address,uint8,string,string)": FunctionFragment;
        "isAccountCritical(address,uint256)": FunctionFragment;
        "isAccountCriticalNow(address)": FunctionFragment;
        "isAccountSolvent(address,uint256)": FunctionFragment;
        "isAccountSolventNow(address)": FunctionFragment;
        "makeLiquidationPayoutsV2(bytes32,bytes,address,bool,address,uint256,int256)": FunctionFragment;
        "proxiableUUID()": FunctionFragment;
        "realtimeBalanceOf(address,uint256)": FunctionFragment;
        "realtimeBalanceOfNow(address)": FunctionFragment;
        "settleBalance(address,int256)": FunctionFragment;
        "terminateAgreement(bytes32,uint256)": FunctionFragment;
        "updateAgreementData(bytes32,bytes32[])": FunctionFragment;
        "updateAgreementStateSlot(address,uint256,bytes32[])": FunctionFragment;
        "updateCode(address)": FunctionFragment;
        "upgrade(uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "castrate" | "createAgreement" | "getAccountActiveAgreements" | "getAgreementData" | "getAgreementStateSlot" | "getCodeAddress" | "getHost" | "initialize" | "isAccountCritical" | "isAccountCriticalNow" | "isAccountSolvent" | "isAccountSolventNow" | "makeLiquidationPayoutsV2" | "proxiableUUID" | "realtimeBalanceOf" | "realtimeBalanceOfNow" | "settleBalance" | "terminateAgreement" | "updateAgreementData" | "updateAgreementStateSlot" | "updateCode" | "upgrade"): FunctionFragment;
    encodeFunctionData(functionFragment: "castrate", values?: undefined): string;
    encodeFunctionData(functionFragment: "createAgreement", values: [BytesLike, BytesLike[]]): string;
    encodeFunctionData(functionFragment: "getAccountActiveAgreements", values: [string]): string;
    encodeFunctionData(functionFragment: "getAgreementData", values: [string, BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getAgreementStateSlot", values: [string, string, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getCodeAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "getHost", values?: undefined): string;
    encodeFunctionData(functionFragment: "initialize", values: [string, BigNumberish, string, string]): string;
    encodeFunctionData(functionFragment: "isAccountCritical", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "isAccountCriticalNow", values: [string]): string;
    encodeFunctionData(functionFragment: "isAccountSolvent", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "isAccountSolventNow", values: [string]): string;
    encodeFunctionData(functionFragment: "makeLiquidationPayoutsV2", values: [
        BytesLike,
        BytesLike,
        string,
        boolean,
        string,
        BigNumberish,
        BigNumberish
    ]): string;
    encodeFunctionData(functionFragment: "proxiableUUID", values?: undefined): string;
    encodeFunctionData(functionFragment: "realtimeBalanceOf", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "realtimeBalanceOfNow", values: [string]): string;
    encodeFunctionData(functionFragment: "settleBalance", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "terminateAgreement", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "updateAgreementData", values: [BytesLike, BytesLike[]]): string;
    encodeFunctionData(functionFragment: "updateAgreementStateSlot", values: [string, BigNumberish, BytesLike[]]): string;
    encodeFunctionData(functionFragment: "updateCode", values: [string]): string;
    encodeFunctionData(functionFragment: "upgrade", values: [BigNumberish]): string;
    decodeFunctionResult(functionFragment: "castrate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "createAgreement", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAccountActiveAgreements", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAgreementData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAgreementStateSlot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCodeAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getHost", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAccountCritical", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAccountCriticalNow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAccountSolvent", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAccountSolventNow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "makeLiquidationPayoutsV2", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proxiableUUID", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "realtimeBalanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "realtimeBalanceOfNow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "settleBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "terminateAgreement", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateAgreementData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateAgreementStateSlot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "upgrade", data: BytesLike): Result;
    events: {
        "AgreementCreated(address,bytes32,bytes32[])": EventFragment;
        "AgreementLiquidated(address,bytes32,address,address,uint256)": EventFragment;
        "AgreementLiquidatedBy(address,address,bytes32,address,address,uint256,uint256)": EventFragment;
        "AgreementLiquidatedV2(address,bytes32,address,address,address,uint256,int256,bytes)": EventFragment;
        "AgreementStateUpdated(address,address,uint256)": EventFragment;
        "AgreementTerminated(address,bytes32)": EventFragment;
        "AgreementUpdated(address,bytes32,bytes32[])": EventFragment;
        "Bailout(address,uint256)": EventFragment;
        "CodeUpdated(bytes32,address)": EventFragment;
        "Initialized(uint8)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AgreementCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AgreementLiquidated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AgreementLiquidatedBy"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AgreementLiquidatedV2"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AgreementStateUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AgreementTerminated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AgreementUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Bailout"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "CodeUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
}
export interface AgreementCreatedEventObject {
    agreementClass: string;
    id: string;
    data: string[];
}
export type AgreementCreatedEvent = TypedEvent<[
    string,
    string,
    string[]
], AgreementCreatedEventObject>;
export type AgreementCreatedEventFilter = TypedEventFilter<AgreementCreatedEvent>;
export interface AgreementLiquidatedEventObject {
    agreementClass: string;
    id: string;
    penaltyAccount: string;
    rewardAccount: string;
    rewardAmount: BigNumber;
}
export type AgreementLiquidatedEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    BigNumber
], AgreementLiquidatedEventObject>;
export type AgreementLiquidatedEventFilter = TypedEventFilter<AgreementLiquidatedEvent>;
export interface AgreementLiquidatedByEventObject {
    liquidatorAccount: string;
    agreementClass: string;
    id: string;
    penaltyAccount: string;
    bondAccount: string;
    rewardAmount: BigNumber;
    bailoutAmount: BigNumber;
}
export type AgreementLiquidatedByEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber
], AgreementLiquidatedByEventObject>;
export type AgreementLiquidatedByEventFilter = TypedEventFilter<AgreementLiquidatedByEvent>;
export interface AgreementLiquidatedV2EventObject {
    agreementClass: string;
    id: string;
    liquidatorAccount: string;
    targetAccount: string;
    rewardAmountReceiver: string;
    rewardAmount: BigNumber;
    targetAccountBalanceDelta: BigNumber;
    liquidationTypeData: string;
}
export type AgreementLiquidatedV2Event = TypedEvent<[
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string
], AgreementLiquidatedV2EventObject>;
export type AgreementLiquidatedV2EventFilter = TypedEventFilter<AgreementLiquidatedV2Event>;
export interface AgreementStateUpdatedEventObject {
    agreementClass: string;
    account: string;
    slotId: BigNumber;
}
export type AgreementStateUpdatedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], AgreementStateUpdatedEventObject>;
export type AgreementStateUpdatedEventFilter = TypedEventFilter<AgreementStateUpdatedEvent>;
export interface AgreementTerminatedEventObject {
    agreementClass: string;
    id: string;
}
export type AgreementTerminatedEvent = TypedEvent<[
    string,
    string
], AgreementTerminatedEventObject>;
export type AgreementTerminatedEventFilter = TypedEventFilter<AgreementTerminatedEvent>;
export interface AgreementUpdatedEventObject {
    agreementClass: string;
    id: string;
    data: string[];
}
export type AgreementUpdatedEvent = TypedEvent<[
    string,
    string,
    string[]
], AgreementUpdatedEventObject>;
export type AgreementUpdatedEventFilter = TypedEventFilter<AgreementUpdatedEvent>;
export interface BailoutEventObject {
    bailoutAccount: string;
    bailoutAmount: BigNumber;
}
export type BailoutEvent = TypedEvent<[string, BigNumber], BailoutEventObject>;
export type BailoutEventFilter = TypedEventFilter<BailoutEvent>;
export interface CodeUpdatedEventObject {
    uuid: string;
    codeAddress: string;
}
export type CodeUpdatedEvent = TypedEvent<[
    string,
    string
], CodeUpdatedEventObject>;
export type CodeUpdatedEventFilter = TypedEventFilter<CodeUpdatedEvent>;
export interface InitializedEventObject {
    version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;
export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;
export interface NoNFTSuperTokenMock extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: NoNFTSuperTokenMockInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        castrate(overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        createAgreement(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        getAccountActiveAgreements(account: string, overrides?: CallOverrides): Promise<[string[]]>;
        getAgreementData(agreementClass: string, id: BytesLike, dataLength: BigNumberish, overrides?: CallOverrides): Promise<[string[]] & {
            data: string[];
        }>;
        getAgreementStateSlot(agreementClass: string, account: string, slotId: BigNumberish, dataLength: BigNumberish, overrides?: CallOverrides): Promise<[string[]] & {
            slotData: string[];
        }>;
        getCodeAddress(overrides?: CallOverrides): Promise<[string] & {
            codeAddress: string;
        }>;
        getHost(overrides?: CallOverrides): Promise<[string] & {
            host: string;
        }>;
        initialize(underlyingToken: string, underlyingDecimals: BigNumberish, n: string, s: string, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        isAccountCritical(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<[boolean] & {
            isCritical: boolean;
        }>;
        isAccountCriticalNow(account: string, overrides?: CallOverrides): Promise<[boolean] & {
            isCritical: boolean;
        }>;
        isAccountSolvent(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<[boolean] & {
            isSolvent: boolean;
        }>;
        isAccountSolventNow(account: string, overrides?: CallOverrides): Promise<[boolean] & {
            isSolvent: boolean;
        }>;
        makeLiquidationPayoutsV2(id: BytesLike, liquidationTypeData: BytesLike, liquidatorAccount: string, useDefaultRewardAccount: boolean, targetAccount: string, rewardAmount: BigNumberish, targetAccountBalanceDelta: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        proxiableUUID(overrides?: CallOverrides): Promise<[string]>;
        realtimeBalanceOf(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            availableBalance: BigNumber;
            deposit: BigNumber;
            owedDeposit: BigNumber;
        }>;
        realtimeBalanceOfNow(account: string, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            availableBalance: BigNumber;
            deposit: BigNumber;
            owedDeposit: BigNumber;
            timestamp: BigNumber;
        }>;
        settleBalance(account: string, delta: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        terminateAgreement(id: BytesLike, dataLength: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        updateAgreementData(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        updateAgreementStateSlot(account: string, slotId: BigNumberish, slotData: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        updateCode(newAddress: string, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        upgrade(amount: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
    };
    castrate(overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    createAgreement(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    getAccountActiveAgreements(account: string, overrides?: CallOverrides): Promise<string[]>;
    getAgreementData(agreementClass: string, id: BytesLike, dataLength: BigNumberish, overrides?: CallOverrides): Promise<string[]>;
    getAgreementStateSlot(agreementClass: string, account: string, slotId: BigNumberish, dataLength: BigNumberish, overrides?: CallOverrides): Promise<string[]>;
    getCodeAddress(overrides?: CallOverrides): Promise<string>;
    getHost(overrides?: CallOverrides): Promise<string>;
    initialize(underlyingToken: string, underlyingDecimals: BigNumberish, n: string, s: string, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    isAccountCritical(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
    isAccountCriticalNow(account: string, overrides?: CallOverrides): Promise<boolean>;
    isAccountSolvent(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
    isAccountSolventNow(account: string, overrides?: CallOverrides): Promise<boolean>;
    makeLiquidationPayoutsV2(id: BytesLike, liquidationTypeData: BytesLike, liquidatorAccount: string, useDefaultRewardAccount: boolean, targetAccount: string, rewardAmount: BigNumberish, targetAccountBalanceDelta: BigNumberish, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    proxiableUUID(overrides?: CallOverrides): Promise<string>;
    realtimeBalanceOf(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        availableBalance: BigNumber;
        deposit: BigNumber;
        owedDeposit: BigNumber;
    }>;
    realtimeBalanceOfNow(account: string, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        availableBalance: BigNumber;
        deposit: BigNumber;
        owedDeposit: BigNumber;
        timestamp: BigNumber;
    }>;
    settleBalance(account: string, delta: BigNumberish, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    terminateAgreement(id: BytesLike, dataLength: BigNumberish, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    updateAgreementData(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    updateAgreementStateSlot(account: string, slotId: BigNumberish, slotData: BytesLike[], overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    updateCode(newAddress: string, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    upgrade(amount: BigNumberish, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    callStatic: {
        castrate(overrides?: CallOverrides): Promise<void>;
        createAgreement(id: BytesLike, data: BytesLike[], overrides?: CallOverrides): Promise<void>;
        getAccountActiveAgreements(account: string, overrides?: CallOverrides): Promise<string[]>;
        getAgreementData(agreementClass: string, id: BytesLike, dataLength: BigNumberish, overrides?: CallOverrides): Promise<string[]>;
        getAgreementStateSlot(agreementClass: string, account: string, slotId: BigNumberish, dataLength: BigNumberish, overrides?: CallOverrides): Promise<string[]>;
        getCodeAddress(overrides?: CallOverrides): Promise<string>;
        getHost(overrides?: CallOverrides): Promise<string>;
        initialize(underlyingToken: string, underlyingDecimals: BigNumberish, n: string, s: string, overrides?: CallOverrides): Promise<void>;
        isAccountCritical(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
        isAccountCriticalNow(account: string, overrides?: CallOverrides): Promise<boolean>;
        isAccountSolvent(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
        isAccountSolventNow(account: string, overrides?: CallOverrides): Promise<boolean>;
        makeLiquidationPayoutsV2(id: BytesLike, liquidationTypeData: BytesLike, liquidatorAccount: string, useDefaultRewardAccount: boolean, targetAccount: string, rewardAmount: BigNumberish, targetAccountBalanceDelta: BigNumberish, overrides?: CallOverrides): Promise<void>;
        proxiableUUID(overrides?: CallOverrides): Promise<string>;
        realtimeBalanceOf(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            availableBalance: BigNumber;
            deposit: BigNumber;
            owedDeposit: BigNumber;
        }>;
        realtimeBalanceOfNow(account: string, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            availableBalance: BigNumber;
            deposit: BigNumber;
            owedDeposit: BigNumber;
            timestamp: BigNumber;
        }>;
        settleBalance(account: string, delta: BigNumberish, overrides?: CallOverrides): Promise<void>;
        terminateAgreement(id: BytesLike, dataLength: BigNumberish, overrides?: CallOverrides): Promise<void>;
        updateAgreementData(id: BytesLike, data: BytesLike[], overrides?: CallOverrides): Promise<void>;
        updateAgreementStateSlot(account: string, slotId: BigNumberish, slotData: BytesLike[], overrides?: CallOverrides): Promise<void>;
        updateCode(newAddress: string, overrides?: CallOverrides): Promise<void>;
        upgrade(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "AgreementCreated(address,bytes32,bytes32[])"(agreementClass?: string | null, id?: null, data?: null): AgreementCreatedEventFilter;
        AgreementCreated(agreementClass?: string | null, id?: null, data?: null): AgreementCreatedEventFilter;
        "AgreementLiquidated(address,bytes32,address,address,uint256)"(agreementClass?: string | null, id?: null, penaltyAccount?: string | null, rewardAccount?: string | null, rewardAmount?: null): AgreementLiquidatedEventFilter;
        AgreementLiquidated(agreementClass?: string | null, id?: null, penaltyAccount?: string | null, rewardAccount?: string | null, rewardAmount?: null): AgreementLiquidatedEventFilter;
        "AgreementLiquidatedBy(address,address,bytes32,address,address,uint256,uint256)"(liquidatorAccount?: null, agreementClass?: string | null, id?: null, penaltyAccount?: string | null, bondAccount?: string | null, rewardAmount?: null, bailoutAmount?: null): AgreementLiquidatedByEventFilter;
        AgreementLiquidatedBy(liquidatorAccount?: null, agreementClass?: string | null, id?: null, penaltyAccount?: string | null, bondAccount?: string | null, rewardAmount?: null, bailoutAmount?: null): AgreementLiquidatedByEventFilter;
        "AgreementLiquidatedV2(address,bytes32,address,address,address,uint256,int256,bytes)"(agreementClass?: string | null, id?: null, liquidatorAccount?: string | null, targetAccount?: string | null, rewardAmountReceiver?: null, rewardAmount?: null, targetAccountBalanceDelta?: null, liquidationTypeData?: null): AgreementLiquidatedV2EventFilter;
        AgreementLiquidatedV2(agreementClass?: string | null, id?: null, liquidatorAccount?: string | null, targetAccount?: string | null, rewardAmountReceiver?: null, rewardAmount?: null, targetAccountBalanceDelta?: null, liquidationTypeData?: null): AgreementLiquidatedV2EventFilter;
        "AgreementStateUpdated(address,address,uint256)"(agreementClass?: string | null, account?: string | null, slotId?: null): AgreementStateUpdatedEventFilter;
        AgreementStateUpdated(agreementClass?: string | null, account?: string | null, slotId?: null): AgreementStateUpdatedEventFilter;
        "AgreementTerminated(address,bytes32)"(agreementClass?: string | null, id?: null): AgreementTerminatedEventFilter;
        AgreementTerminated(agreementClass?: string | null, id?: null): AgreementTerminatedEventFilter;
        "AgreementUpdated(address,bytes32,bytes32[])"(agreementClass?: string | null, id?: null, data?: null): AgreementUpdatedEventFilter;
        AgreementUpdated(agreementClass?: string | null, id?: null, data?: null): AgreementUpdatedEventFilter;
        "Bailout(address,uint256)"(bailoutAccount?: string | null, bailoutAmount?: null): BailoutEventFilter;
        Bailout(bailoutAccount?: string | null, bailoutAmount?: null): BailoutEventFilter;
        "CodeUpdated(bytes32,address)"(uuid?: null, codeAddress?: null): CodeUpdatedEventFilter;
        CodeUpdated(uuid?: null, codeAddress?: null): CodeUpdatedEventFilter;
        "Initialized(uint8)"(version?: null): InitializedEventFilter;
        Initialized(version?: null): InitializedEventFilter;
    };
    estimateGas: {
        castrate(overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        createAgreement(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        getAccountActiveAgreements(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        getAgreementData(agreementClass: string, id: BytesLike, dataLength: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getAgreementStateSlot(agreementClass: string, account: string, slotId: BigNumberish, dataLength: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getCodeAddress(overrides?: CallOverrides): Promise<BigNumber>;
        getHost(overrides?: CallOverrides): Promise<BigNumber>;
        initialize(underlyingToken: string, underlyingDecimals: BigNumberish, n: string, s: string, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        isAccountCritical(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isAccountCriticalNow(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        isAccountSolvent(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isAccountSolventNow(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        makeLiquidationPayoutsV2(id: BytesLike, liquidationTypeData: BytesLike, liquidatorAccount: string, useDefaultRewardAccount: boolean, targetAccount: string, rewardAmount: BigNumberish, targetAccountBalanceDelta: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;
        realtimeBalanceOf(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        realtimeBalanceOfNow(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        settleBalance(account: string, delta: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        terminateAgreement(id: BytesLike, dataLength: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        updateAgreementData(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        updateAgreementStateSlot(account: string, slotId: BigNumberish, slotData: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        updateCode(newAddress: string, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        upgrade(amount: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        castrate(overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        createAgreement(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        getAccountActiveAgreements(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAgreementData(agreementClass: string, id: BytesLike, dataLength: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAgreementStateSlot(agreementClass: string, account: string, slotId: BigNumberish, dataLength: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCodeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getHost(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(underlyingToken: string, underlyingDecimals: BigNumberish, n: string, s: string, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        isAccountCritical(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isAccountCriticalNow(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isAccountSolvent(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isAccountSolventNow(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        makeLiquidationPayoutsV2(id: BytesLike, liquidationTypeData: BytesLike, liquidatorAccount: string, useDefaultRewardAccount: boolean, targetAccount: string, rewardAmount: BigNumberish, targetAccountBalanceDelta: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        realtimeBalanceOf(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        realtimeBalanceOfNow(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        settleBalance(account: string, delta: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        terminateAgreement(id: BytesLike, dataLength: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        updateAgreementData(id: BytesLike, data: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        updateAgreementStateSlot(account: string, slotId: BigNumberish, slotData: BytesLike[], overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        updateCode(newAddress: string, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        upgrade(amount: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=NoNFTSuperTokenMock.d.ts.map